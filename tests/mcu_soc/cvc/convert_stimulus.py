# /// script
# requires-python = ">=3.10"
# dependencies = []
# ///
"""Convert a Loom stimulus VCD to Verilog timed assignments for CVC.

Reads the stimulus VCD (generated by `loom cosim --stimulus-vcd`) and produces
a Verilog include file with delay-based `initial begin ... end` blocks that
drive the DUT ports.

When --config is provided, the port_mapping.inputs from the JSON config is
used to translate Jacquard internal port names (e.g. io$clk$i) back to
CVC testbench names (e.g. gpio_in[38]).

Usage:
    uv run tests/mcu_soc/cvc/convert_stimulus.py \
        tests/mcu_soc/cvc/stimulus.vcd \
        tests/mcu_soc/cvc/stimulus_gen.v \
        --config tests/mcu_soc/sim_config.json
"""

import json
import re
import sys
from pathlib import Path


def parse_vcd(vcd_path: Path) -> tuple[dict[str, str], list[tuple[int, list[tuple[str, int]]]]]:
    """Parse a VCD file, return (id_to_name, timestamps_with_changes).

    Returns:
        id_to_name: mapping from VCD ID code to signal name
        events: list of (timestamp, [(id, value), ...])
    """
    id_to_name: dict[str, str] = {}
    events: list[tuple[int, list[tuple[str, int]]]] = []

    in_header = True
    current_ts = 0
    current_changes: list[tuple[str, int]] = []

    with open(vcd_path) as f:
        for line in f:
            line = line.strip()
            if not line:
                continue

            if in_header:
                # Parse variable definitions
                m = re.match(r'\$var\s+\w+\s+\d+\s+(\S+)\s+(.+?)\s*\$end', line)
                if m:
                    vid, name = m.group(1), m.group(2)
                    # Normalize "gpio_in [38]" → "gpio_in[38]" (remove space
                    # between name and bit select that vcd-ng adds).
                    # Also handle redundant trailing index like "signal[0] [0]"
                    # by collapsing to just "signal[0]".
                    name = re.sub(r'\s+\[(\d+)\]$', r'[\1]', name)
                    id_to_name[vid] = name
                elif line.startswith('$enddefinitions'):
                    in_header = False
                continue

            # Parse timestamps and value changes
            if line.startswith('#'):
                if current_changes:
                    events.append((current_ts, current_changes))
                    current_changes = []
                current_ts = int(line[1:])
            elif line.startswith('$'):
                # Skip $dumpvars, $end, etc.
                continue
            elif len(line) >= 2 and line[0] in '01xXzZ':
                val = 1 if line[0] == '1' else 0
                vid = line[1:]
                current_changes.append((vid, val))

    if current_changes:
        events.append((current_ts, current_changes))

    return id_to_name, events


def map_signals_to_ports(id_to_name: dict[str, str]) -> dict[str, tuple[str, int | None]]:
    """Map VCD signal names to (port_name, bit_index) pairs.

    E.g., "gpio_in[5]" -> ("gpio_in", 5)
          "por_l" -> ("por_l", None)
    """
    result: dict[str, tuple[str, int | None]] = {}
    for vid, name in id_to_name.items():
        m = re.match(r'(.+)\[(\d+)\]$', name)
        if m:
            result[vid] = (m.group(1), int(m.group(2)))
        else:
            result[vid] = (name, None)
    return result


    # Ports that are inout or shouldn't be driven from stimulus
EXCLUDED_PORTS = {'analog_io', 'analog_noesd_io'}


def build_reverse_port_mapping(config_path: Path) -> dict[str, str]:
    """Build internal_name → gpio_in[N] mapping from sim config.

    The config's port_mapping.inputs maps gpio_number → internal_name.
    We invert it so internal_name → "gpio_in[gpio_number]".

    For multi-bit internal ports like io$soc_flash_d$i[0], the mapping is:
        "2" → "io$soc_flash_d$i[0]"  becomes  "io$soc_flash_d$i[0]" → "gpio_in[2]"
    For scalar ports like io$clk$i:
        "38" → "io$clk$i"  becomes  "io$clk$i" → "gpio_in[38]"
    """
    with open(config_path) as f:
        config = json.load(f)

    mapping: dict[str, str] = {}
    pm = config.get("port_mapping", {})
    for gpio_num, internal_name in pm.get("inputs", {}).items():
        mapping[internal_name] = f"gpio_in[{gpio_num}]"

    # Also map constant_inputs (e.g. JTAG trst tied high)
    for gpio_num in config.get("constant_inputs", {}):
        if gpio_num not in pm.get("inputs", {}):
            # No internal name known; these are driven by the testbench initial block
            pass

    return mapping


def generate_verilog(
    id_to_name: dict[str, str],
    events: list[tuple[int, list[tuple[str, int]]]],
    output_path: Path,
    port_name_map: dict[str, str] | None = None,
) -> None:
    """Generate Verilog stimulus file with timed assignments.

    Args:
        port_name_map: Optional mapping from VCD signal name to Verilog target.
            When provided, VCD signal names are translated (e.g.,
            "io$clk$i" → "gpio_in[38]").
    """
    # Remap VCD signal names if a port mapping is provided
    if port_name_map:
        remapped: dict[str, str] = {}
        unmapped = []
        for vid, name in id_to_name.items():
            if name in port_name_map:
                remapped[vid] = port_name_map[name]
            else:
                unmapped.append(name)
        if unmapped:
            print(f"  Warning: {len(unmapped)} signals not in port mapping: {unmapped[:5]}")
        id_to_name = remapped

    port_map = map_signals_to_ports(id_to_name)

    # Collect all unique ports and their widths
    port_widths: dict[str, int] = {}  # port_name -> max bit index + 1
    scalar_ports: set[str] = set()
    for _vid, (port_name, bit_idx) in port_map.items():
        if port_name in EXCLUDED_PORTS:
            continue
        if bit_idx is not None:
            port_widths[port_name] = max(port_widths.get(port_name, 0), bit_idx + 1)
        else:
            scalar_ports.add(port_name)

    with open(output_path, 'w') as f:
        f.write("// Auto-generated stimulus from Loom cosim VCD\n")
        f.write(f"// Source: stimulus.vcd\n")
        f.write(f"// Signals: {len(id_to_name)}, Events: {len(events)}\n")
        f.write(f"// Ports: {sorted(port_widths.keys())} + {sorted(scalar_ports)}\n\n")

        f.write("initial begin\n")

        prev_ts = 0
        for ts, changes in events:
            delay = ts - prev_ts
            if delay > 0:
                f.write(f"  #{delay};\n")
            elif ts == 0 and prev_ts == 0:
                pass  # no delay for initial
            prev_ts = ts

            # Group changes by port for readability
            for vid, val in changes:
                if vid not in port_map:
                    continue
                port_name, bit_idx = port_map[vid]
                if port_name in EXCLUDED_PORTS:
                    continue
                val_str = f"1'b{val}"
                if bit_idx is not None:
                    f.write(f"  {port_name}[{bit_idx}] = {val_str};\n")
                else:
                    f.write(f"  {port_name} = {val_str};\n")

        # Add finish after last event + one more clock period
        f.write("  #80000;\n")
        f.write("  $finish;\n")
        f.write("end\n")

    total_changes = sum(len(c) for _, c in events)
    print(f"Generated {output_path}: {len(events)} timestamps, {total_changes} value changes")
    print(f"  Bus ports: {dict(sorted(port_widths.items()))}")
    print(f"  Scalar ports: {sorted(scalar_ports)}")


def main() -> None:
    # Simple argument parsing: <stimulus.vcd> <output.v> [--config <config.json>]
    args = sys.argv[1:]
    config_path: Path | None = None
    positional: list[str] = []

    i = 0
    while i < len(args):
        if args[i] == "--config" and i + 1 < len(args):
            config_path = Path(args[i + 1])
            i += 2
        else:
            positional.append(args[i])
            i += 1

    if len(positional) != 2:
        print(
            f"Usage: {sys.argv[0]} <stimulus.vcd> <output.v> [--config <config.json>]",
            file=sys.stderr,
        )
        sys.exit(1)

    vcd_path = Path(positional[0])
    output_path = Path(positional[1])

    if not vcd_path.exists():
        print(f"Error: {vcd_path} not found", file=sys.stderr)
        sys.exit(1)

    port_name_map: dict[str, str] | None = None
    if config_path:
        if not config_path.exists():
            print(f"Error: config {config_path} not found", file=sys.stderr)
            sys.exit(1)
        port_name_map = build_reverse_port_mapping(config_path)
        print(f"Loaded port mapping from {config_path}: {len(port_name_map)} input mappings")

    id_to_name, events = parse_vcd(vcd_path)
    print(f"Parsed {vcd_path}: {len(id_to_name)} signals, {len(events)} timestamps")

    generate_verilog(id_to_name, events, output_path, port_name_map)


if __name__ == '__main__':
    main()
