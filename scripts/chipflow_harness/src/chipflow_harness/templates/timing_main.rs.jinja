//! Generated testbench for timing simulation.
//!
//! This file is generated by chipflow_harness from pins.lock.
//! Do not edit manually.

use gem::timing_sim::{TimingSimulator, PeripheralModel};

fn main() {
    clilog::init_stderr_color_debug();

    // Load netlist and build simulator
    let mut sim = TimingSimulator::from_netlist(
        "{{ netlist_path }}",
        "{{ liberty_path }}",
    ).expect("Failed to load netlist");

    // Configure clock and reset
    sim.set_clock_gpio({{ clock_gpio }});
    sim.set_reset_gpio({{ reset_gpio }});
    sim.set_reset_active_high({{ reset_active_high | lower }});

    {% if flash %}
    // Configure QSPI flash
    let mut flash = sim.add_flash_model(
        {{ flash.clk_gpio }},  // clk
        {{ flash.csn_gpio }},  // csn
        {{ flash.d0_gpio }},   // d0 (d1-d3 are consecutive)
    );
    flash.load_firmware("{{ flash.firmware }}", {{ flash.firmware_offset }});
    {% endif %}

    {% if uart %}
    // Configure UART
    sim.add_uart_model(
        {{ uart.tx_gpio }},  // tx (output from design)
        {{ uart.rx_gpio }},  // rx (input to design)
        {{ uart.baud_rate }},
    );
    {% endif %}

    {% for gpio in gpios %}
    // Configure GPIO: {{ gpio.name }}
    sim.add_gpio_model(
        "{{ gpio.name }}",
        &[{% for pin in gpio.pins %}{{ pin }}{% if not loop.last %}, {% endif %}{% endfor %}],
    );
    {% endfor %}

    // Initialize SRAM from ELF .data section
    {% if sram_init %}
    sim.init_sram_from_elf("{{ sram_init.elf_path }}");
    {% endif %}

    // Run reset sequence
    clilog::info!("Running reset sequence ({} cycles)...", {{ reset_cycles }});
    sim.run_reset({{ reset_cycles }});

    // Run simulation
    clilog::info!("Running simulation ({} cycles)...", {{ num_cycles }});
    for cycle in 0..{{ num_cycles }} {
        // Step all peripheral models
        sim.step_models();

        // Advance clock (falling edge)
        sim.clock_fall();
        sim.evaluate();

        // Advance clock (rising edge)
        sim.clock_rise();
        sim.evaluate();
        sim.latch_dffs();

        // Check for termination conditions
        {% if termination_event %}
        if sim.check_event("{{ termination_event }}") {
            clilog::info!("Termination event detected at cycle {}", cycle);
            break;
        }
        {% endif %}

        if cycle % 100000 == 0 {
            clilog::info!("Cycle {}", cycle);
        }
    }

    // Output results
    sim.print_timing_summary();

    {% if output_events %}
    sim.write_events("{{ output_events }}");
    {% endif %}
}
