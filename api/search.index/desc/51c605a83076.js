rd_("AmThe Q pin output with invert.0AbPartition executor0BcAn AIG associated with a netlistdb.0AbSingle-bit signal.0B`Driven by a DFF (with its index)fA DFF.10AnLog the violation and continueAlLog the failure and continue10AiAnd-inverter graph format0BmLoom \xe2\x80\x94 GPU-accelerated RTL logic simulator.BoGet the current number of events in the buffer.0BiNet name pattern to match in the netlist.0CiCreate a new CellInputs with all pins set to MAX (unset).CnCreate a new traverser for an AIG with the given number of \xe2\x80\xa6BnCreate a new PackedDelay from rise/fall times.B`Create a new empty event buffer.DhCreate a new UART monitor. <code>clock_hz</code> is the system clock \xe2\x80\xa643210CgShared simulation infrastructure for GPU simulation \xe2\x80\xa60CgDriven by a 13-bit by 32-bit RAM block (with its index)0Ah$stop - pause simulationBd$stop system task - pause simulation10CkTie0: tied to zero. Only the 0-th aig pin is allowed to \xe2\x80\xa60AaWarn and continue0BfThe D input pin with invert (last bit)0BjData payload for $display format arguments0BhDestination port path (e.g., \xe2\x80\x9ci0.A\xe2\x80\x9d)0BkThe D flip-flops (DFFs), indexed by cell id0AoReturns the argument unchanged.000000000000000000000000000000000000Aibuild a flattened script.111111111111111111111111111111111111111111111111111111111111111111111111111111011111111111111111111111111111111111111111AnGPIO index driving this clock.Ckthe boomerang hierarchy, 8192 -&gt; 4096 -&gt; \xe2\x80\xa6 -&gt; 1.0BaCalls <code>U::from(self)</code>.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000BkIterate over events without consuming them.0nPrimitive namehPin nameiCell namelLibrary nameAlDisplay name for the signal.4321CeHuman-readable name for this clock domain (optional).1BiPin timing information, keyed by pin name0A`Truth table rows0CkStep the UART monitor with the current TX pin value and \xe2\x80\xa60BdUDP models indexed by primitive name0ChA single event written by the GPU. Layout must match \xe2\x80\xa60BlMixed cells from both libraries (error case)0BePause simulation (for $stop or debug)AmPause simulation (like $stop)10CmAlignment: \xe2\x80\x98&lt;\xe2\x80\x99 left, \xe2\x80\x98&gt;\xe2\x80\x99 right, \xe2\x80\x98^\xe2\x80\x99 center.0BhCells in the library, keyed by cell name0ClNumber of events currently in the buffer (atomic for GPU \xe2\x80\xa60BhSimulation cycle when the event occurred0CnDrain all events from the buffer, processing each with the \xe2\x80\xa60CiIf the DFF is enabled, i.e., if the clock, S, or R is \xe2\x80\xa60AlGate instantiations in order0BdParse Liberty content from a string.0CiDisplay format: \xe2\x80\x98d\xe2\x80\x99 decimal, \xe2\x80\x98h\xe2\x80\x99 hex, \xe2\x80\x98b\xe2\x80\x99 \xe2\x80\xa60BaReset the buffer for a new cycle.0CkDesign loading pipeline: netlist \xe2\x86\x92 AIG \xe2\x86\x92 staged \xe2\x86\x92 \xe2\x80\xa60AmThe SRAMs, indexed by cell id0AjBit width of the argument.CeWidth for bundle signals (e.g., 32 for a 32-bit bus).10AoEnable selective X-propagation.AeAIGPDK standard cells0BkMulti-bit bundle (pins ordered LSB to MSB).0An$finish - terminate simulationBj$finish system task - terminate simulation10AfSKY130 open-source PDK0BbA single row in a UDP truth table.0ChAIGPDK is a special artificial cell library used in GEM.0CiMulti-clock domain configuration. When set, overrides \xe2\x80\xa6oThe event array0BbThe format string for this displayBlFormat string from the gem_format attribute.CfFormat for output: \xe2\x80\x9cbin\xe2\x80\x9d, \xe2\x80\x9chex\xe2\x80\x9d, or \xe2\x80\x9cdec\xe2\x80\x9d.210B`Input wire names (in port order)CnModule input port names (e.g. [\xe2\x80\x9cA1\xe2\x80\x9d, \xe2\x80\x9cA2\xe2\x80\x9d, \xe2\x80\x9cB1\xe2\x80\x9d\xe2\x80\xa6CiInput values: Some(true)=1, Some(false)=0, None=don\xe2\x80\x99\xe2\x80\xa6AiInput port names in orderCmGPIO index \xe2\x86\x92 input port name (external signals entering \xe2\x80\xa643210ClBehavioral models indexed by cell type (e.g. \xe2\x80\x9co21ai\xe2\x80\x9d \xe2\x80\xa60A`Output wire namelOutput valueA`Output port name210AlWhether the value is signed.0BmSKY130 standard cell library support for GEM.0C`Source port path (e.g., \xe2\x80\x9cdff_in.Q\xe2\x80\x9d or \xe2\x80\x9c\xe2\x80\xa60Aethe boomerang stages.0CgTiming simulation configuration for post-layout SDF \xe2\x80\xa60CePack into a single u32 for GPU transfer. Format: [\xe2\x80\xa60BjVCD input/output utilities for simulation.0AfDriven by an and gate.0B`$display/$write output (Phase 2)0AmA cell entry in the SDF file.0A`Parsed SDF file.0BhHierarchical name representation in VCD.0BnThe argument signals (each entry is aigpin_iv)0BaDFF cell ID (for error reporting)0AmThe driver types of AIG pins.0AnCell fall delay in picoseconds0AeThe fanout CSR array.0BaPartition scheduler and flattener0AhHold time in picoseconds0Bn(aigpin, output_pos_in_state, vcd_variable_id)0BiModule output port names (e.g. [\xe2\x80\x9cY\xe2\x80\x9d])CjGPIO index \xe2\x86\x92 output port name (signals driven by the \xe2\x80\xa610AnCell rise delay in picoseconds0ChSet a pin value by name. Returns true if the pin was \xe2\x80\xa60ClSplitting deep circuit into major stages at global level \xe2\x80\xa60BdSummary statistics for debug output.0AlContinue simulation normally0DeA ram block resembling the interface of <code>$__RAMGEM_SYNC_</code>.0BkDelay value in picoseconds (rise and fall).0BeStatistics tracked during simulation.0BnA parsed Verilog UDP (User Defined Primitive).0BiThe clock enable signal (posedge trigger)0mData pin name0CgThe display nodes ($display/$write), indexed by cell id0AbUnpack from a u32.0CdCreate a PackedDelay from u64 picosecond values, \xe2\x80\xa60AnGet timing for a cell by name.B`Look up a cell by instance path.10CaInstance path (empty string for top-level module)0AkWhether this pin is a clock0CaJacquard \xe2\x80\x94 GPU-accelerated RTL logic simulator.BcLoad SDF timing data into a script.0AkGet maximum hold time (ps).0CfFlag indicating if events were dropped due to overflow0BcPad character (\xe2\x80\x980\xe2\x80\x99 or \xe2\x80\x99 \xe2\x80\x99).0CcPath to SDF file from OpenLane2 (e.g. 6_final.sdf).0AiSetup time in picoseconds0AoConstraint value in picoseconds0AfDFF timing parameters.0BlEvent types that can be reported by the GPU.0CgDriven by a primary input port (with its netlistdb id).0CeOne partitioned block: a basic execution unit on GPU.0CcCollection of loaded PDK models for a cell library.0BdTiming information for a single pin.0BmWhich corner of (min:typ:max) triples to use.0ChAn IOPATH delay entry: input_pin \xe2\x86\x92 output_pin with \xe2\x80\xa60CeA struct representing the boundaries of a staged AIG.0CeTerminate simulation (for $finish or fatal assertion)AdTerminate simulationBcTerminate simulation (like $finish)210BnTiming arc from an input pin to an output pin.0AcDecoded UART event.0AnUART TX decoder state machine.0BiWatchlist configuration loaded from JSON.0AnReserved for padding/alignmentAfReserved for alignment10CkSequence of AND gate operations to build. Each entry is \xe2\x80\xa60BdGet delay for the buffer cell (BUF).0Chbuild one partition given a set of endpoints to realize.0CaThe cell name (for matching with JSON attributes)0CiPin direction (\xe2\x80\x9cinput\xe2\x80\x9d, \xe2\x80\x9coutput\xe2\x80\x9d, \xe2\x80\x9cinternal\xe2\x80\x9d)0CiEdge type per position: 0 = any, 1 = rising, 2 = falling.0CnThe enable condition input pin with invert (last bit) When \xe2\x80\xa60Cmthe endpoint indices of original AIG fulfilled by current \xe2\x80\xa6Cbthe endpoints that are realized by this partition.10BhLoad a Liberty library from a file path.0CmGate type: \xe2\x80\x9cand\xe2\x80\x9d, \xe2\x80\x9cor\xe2\x80\x9d, \xe2\x80\x9cnand\xe2\x80\x9d, \xe2\x80\x9cnor\xe2\x80\x9d, \xe2\x80\x9c\xe2\x80\xa60BoGet the packed delay for an AIG pin (by index).0CeGet hold time for data pin relative to clock (for \xe2\x80\xa60Ckmaps from primary inputs, FF:Q/SRAM:* input AIG pins to \xe2\x80\xa60BfGet delay for the inverter cell (INV).0BnPath to JSON file with display format strings.0CcGet the maximum delay (for critical path analysis).0AlGet maximum setup time (ps).0BdMinimum display width (for padding).0B`Parse an SDF file from a string.0BiParse a Verilog UDP primitive definition.0BlRun mt-kahypar to partition this hypergraph.0CcClock period in picoseconds (e.g. 40000 for 25MHz).CfShared testbench infrastructure for timing and GPU \xe2\x80\xa60AkTime unit (e.g., \xe2\x80\x9c1ps\xe2\x80\x9d)0AkAssertion failure (Phase 3)0CmFixed-size struct for collecting input pins during SKY130 \xe2\x80\xa60AnTiming information for a cell.0B`Parameters for loading a design.0AnThe driver type of an AIG pin.0CnParse a Yosys format string and extract format specifiers. \xe2\x80\xa60ClMaximum number of events that can be buffered per cycle. \xe2\x80\xa60AgSRAM timing parameters.0CkWhat action the simulation should take after processing \xe2\x80\xa60BgStatistics from X-propagation analysis.AoThe bit widths of each argument0CeArgument width in bits from gem_args_width attribute.0Ai\xe2\x80\x9cSETUP\xe2\x80\x9d or \xe2\x80\x9cHOLD\xe2\x80\x9d0CbClock edge specification (e.g., \xe2\x80\x9cposedge CLK\xe2\x80\x9d)0CkGet clock-to-Q delay for output pin (for sequential cells).0BkDFF timing constraints loaded from Liberty.AkGet DFF timing information.10CgEvent type (see EventType enum) - u32 for GPU alignment0Cibuild a staged AIG by vertical splitting at the given \xe2\x80\xa60BbCheck if timing data is available.0BhOptional message ID for display purposesCnMessage ID for $display and assertions (index into message \xe2\x80\xa610Adthe number of blocks0BcAction to take on assertion failure0CkIndex of the final output (-1 = first gate, -2 = second \xe2\x80\xa60Ckmaps from primary outputs, FF:D and SRAM:PORT_R_RD_DATA \xe2\x80\xa60BcParse an SDF file from a file path.0CiSDF corner selection: \xe2\x80\x9cmin\xe2\x80\x9d, \xe2\x80\x9ctyp\xe2\x80\x9d, or \xe2\x80\x9cmax\xe2\x80\x9d.0CaParser for Standard Delay Format (SDF) 3.0 files.0CfGet setup time for data pin relative to clock (for \xe2\x80\xa60CiSKY130 PDK behavioral model parser and AIG decomposition.0AeNumber of $stop calls0AiTotal number of AIG pins.Cnthe 32-packed elements in the hierarchy where there should \xe2\x80\xa60AoThe detected cell library type.0BhConfiguration for a single clock domain.BlSafe wrapper around the C++ SPI flash model.0CjA display node for $display/$write system tasks. These \xe2\x80\xa60CjThe event buffer structure shared between GPU and CPU. \xe2\x80\xa60CiPacked delay representation for GPU consumption. Uses \xe2\x80\xa60ClMaps GPIO indices to netlist port names for designs with \xe2\x80\xa60CfUART TX monitor that decodes serial output into bytes.0Akthe partition instructions.0ClGate delays for each AIG pin: (rise_ps, fall_ps). Loaded \xe2\x80\xa6CnPer-AIG-pin delays loaded from Liberty library. Index 0 is \xe2\x80\xa610DgHold slack for each DFF (indexed by position in <code>dffs</code>). \xe2\x80\xa60CcCheck if a cell is a tie cell (constant generator).0CkLoad the default AIGPDK library from the standard location.0ClLoad a design through the full pipeline: netlist \xe2\x86\x92 AIG \xe2\x80\xa60C`Load timing data from a Liberty library and AIG.0BoModule name (e.g. \xe2\x80\x9csky130_fd_sc_hd__o21ai\xe2\x80\x9d)0AgThe number of AIG pins.0AhRelated (input) pin name0AmSignal type (reg, comb, mem).0ClThe simulation control nodes ($stop/$finish), indexed by \xe2\x80\xa60AlGet SRAM timing information.0AlTiming arcs from/to this pin0CmTiming type (e.g., \xe2\x80\x9csetup_rising\xe2\x80\x9d, \xe2\x80\x9chold_rising\xe2\x80\x9d, \xe2\x80\xa60CnPack into two u32s for GPU transfer. Returns (timing_word, \xe2\x80\xa60BgAction to take when an assertion fails.0CcConfiguration for how assertions should be handled.0CaResult of decomposing a cell into AIG operations.0CeResult of loading a design: everything needed for \xe2\x80\xa60BnAction to take when a timing violation occurs.0CkConfiguration for timing violation handling (Experiment 4).0BcSummary of timing analysis results.0AfAddress hold time (ps)0Bkthe CSR start indices of stages and blocks.0AnCell fall delay in picoseconds0AnCell rise delay in picoseconds0ClThe condition input pin with invert (last bit) When this \xe2\x80\xa60BaThe control type (Stop or Finish)0CbGet DFFSR (DFF with set/reset) timing information.0BoEvent buffer for GPU\xe2\x86\x92CPU communication of \xe2\x80\xa60CaCheck if any events were dropped due to overflow.0BjHold time for falling data transition (ps)0BiHold time for rising data transition (ps)0Anexpected input AIG pins layout0CkFlattened input state vectors, one per cycle + trailing \xe2\x80\xa60CbQuick lookup: instance path \xe2\x86\x92 index in cells vec0BbGet maximum clock-to-Q delay (ps).0CfMaximum number of failures before stopping (None = \xe2\x80\xa60AbMake an edge list.0BbAction to take on timing violation0CjMaps GPIO indices to actual port names in the netlist. \xe2\x80\xa60Ckcontrols whether r_rd_data should update. (from read clock)0DhSetup slack for each DFF (indexed by position in <code>dffs</code>). \xe2\x80\xa60BhDFF timing constraints for GPU checking.0CmA type of endpoint group. can be a primary output-related \xe2\x80\xa60BbHold time violation (Experiment 4)0DkGPU-side monitor descriptor (must match Metal <code>MonitorConfig</code>\xe2\x80\xa60CeA Liberty timing library containing cell timing data.0CkA reusable topological traverser with dense visited buffer.0AgAddress setup time (ps)0CnArrival times for each AIG pin: (min_ps, max_ps). Computed \xe2\x80\xa60CaCPU-side partition executor for script version 1.0AkThe fanout CSR start array.0Bobuild a staged AIG that consists of all levels.0CgNumber of timing endpoints analyzed (DFFs + primary \xe2\x80\xa60CkNumber of X sources (DFF Q outputs + SRAM read data ports).BoThe mapping from a netlistdb pin to an AIG pin.0BkSetup time for falling data transition (ps)0BjSetup time for rising data transition (ps)0CbPerform a topological traversal, equivalent to \xe2\x80\xa60CjWhether X-propagation is enabled for this design. When \xe2\x80\xa6CmThis implements direction and width providers for AIG PDK \xe2\x80\xa60CiA single gate instantiation from a functional Verilog \xe2\x80\xa60AcOne Boomerang stage0CmDriven by a clock flag (with clock port netlistdb id, and \xe2\x80\xa60ClResult of parsing input VCD: the state vectors and cycle \xe2\x80\xa60CiLeafPinProvider implementation for SKY130 standard cells.0CbA TIMINGCHECK entry for setup or hold constraints.0BcSetup time violation (Experiment 4)0CmA simulation control node for $stop/$finish system tasks. \xe2\x80\xa60BnSimulation control type for $stop and $finish.0DhReverse iterator of a <code>VCDHier</code>, yielding cell names from \xe2\x80\xa60CgResolved watchlist entry - either single bit or bundle.0B`A cache for identical and gates.0ChGet combinational delay for an AND gate variant. The \xe2\x80\xa60CaCompute static timing analysis (STA) for the AIG.0CkConstant port values: port name \xe2\x86\x92 value (0 or 1). For \xe2\x80\xa60BiPosition of D input data arrival in state0CiCreate a TimingLibrary with default SKY130 timing values.0BoDetect which cell library is used in a netlist.0BhNumber of events dropped due to overflow0BnFind a scope by its path in the VCD hierarchy.0CiEnumerate all related aigpin inputs for this endpoint \xe2\x80\xa60AnBuild an AIG from a netlistdb.0C`Returns true if there are any timing violations.0BgCheck if a cell name is an AIGPDK cell.0CeCheck if a cell name is a SKY130 standard cell or \xe2\x80\xa60CkSimple Liberty (.lib) parser for extracting timing data \xe2\x80\xa60ChMaximum number of violations before stopping (None = \xe2\x80\xa60Bothe staged primary inputs from previous levels.0CkProcess events from the buffer and determine simulation \xe2\x80\xa60BdWhether timing data has been loaded.0BmA parsed functional Verilog model for a cell.0CmInformation about a GEM_DISPLAY cell extracted from Yosys \xe2\x80\xa60CeAn INTERCONNECT delay entry: source \xe2\x86\x92 dest with \xe2\x80\xa60BiTestbench configuration loaded from JSON.0ClConfiguration for post-layout timing simulation with SDF \xe2\x80\xa60BcWatchlist signal entry (from JSON).0CgClock period in picoseconds (for STA calculations). \xe2\x80\xa6BnClock period in picoseconds for timing checks.ClClock period in picoseconds (e.g. 40000 for 25MHz). Used \xe2\x80\xa61CkClock period in picoseconds for SDF timing. Defaults to \xe2\x80\xa63212CiConstant input values: GPIO index \xe2\x86\x92 value (0 or 1). \xe2\x80\xa60ClDelay injection info for GPU kernel. Each entry: (offset \xe2\x80\xa60CmDFF timing constraints for setup/hold checking. One entry \xe2\x80\xa60CdBuild a flattened script with X-propagation support.AiNumber of hold violationsBoNumber of hold timing violations (Experiment 4)10CcLoad all PDK models needed for a set of cell types.0BbWhether to invert the final output0CgParse input VCD flow into state vectors for simulation.0ChPhase offset in picoseconds from time zero (default: 0).Bjcontrols whether memory should be updated.0BdUnique primary output aigpin indices0BgState bit positions to watch for edges.0BgInformation needed to write output VCD.0BhClock-to-Q delay for falling output (ps)0BgClock-to-Q delay for rising output (ps)0BjReturn the effective clock configurations.CkTry to match one component in a scope path. Returns the \xe2\x80\xa60BkMatch VCD variables to netlist input ports.0Ajthe number of major stages0CjRun CPU sanity check comparing GPU results against CPU \xe2\x80\xa60ClSet up output VCD writer: add wire definitions and build \xe2\x80\xa60AjNumber of setup violationsC`Number of setup timing violations (Experiment 4)10BgWorst hold slack (negative = violation)0BgWrite simulation results to output VCD.0CmA flattened script, for partition executor version 1. See \xe2\x80\xa60CkGPU\xe2\x86\x94CPU peripheral callback control block (must match \xe2\x80\xa60CkDescribes a GPIO output to watch for edges on the GPU side.0CjOR bitset <code>src</code> into <code>dst</code> in-place.0ChGiven the level split points, return a list of split \xe2\x80\xa60CkThe clock pins map. Every clock pin has a pair of flag pins0ChIdentify DFF Q outputs and SRAM read data ports as X \xe2\x80\xa6ClMaps from display cell IDs to their enable positions and \xe2\x80\xa60BoExtract the cell type from a SKY130 macro name.0Cathe state size including DFF and I/O states only.0CfResolve the top scope from VCD header, either from \xe2\x80\xa60CfCPU prototype partition executor for script version 1.0Bgthe u32 array length for storing SRAMs.0BhWorst setup slack (negative = violation)0BhNumber of assertion failures encountered0CdRecursively collect all scope paths from VCD header.0BbDecompose a cell using PDK models.0BoFall constraint (for setup/hold) in picoseconds0CgGet the critical path endpoints (nodes with longest \xe2\x80\xa60BmGet the virtual endpoint group with an index.0ChCheck if a cell type is a sequential element (DFF or \xe2\x80\xa6CgNumber of X-capable AIG pins after forward propagation.Cd(offset_into_input_states, vcd_timestamp) per cycle.0CfGiven an initial clustering solution of endpoints, \xe2\x80\xa60BoRise constraint (for setup/hold) in picoseconds0CkExtract value-only states from a doubled GPU output buffer.Cmbuild a staged AIG by horizontal splitting given a subset \xe2\x80\xa60AiWrite data hold time (ps)0CjOffset into the state buffer where X-mask words begin. \xe2\x80\xa6CfMaps AIG pin index \xe2\x86\x92 list of (netlistdb cell_id, \xe2\x80\xa60CmMaps from assertion cell IDs to their condition positions \xe2\x80\xa60BbCritical path delay in picoseconds0BeNumber of fixpoint iterations needed.BoLoad timing information from a Liberty library.0CnGet the number of endpoint groups that should be fulfilled \xe2\x80\xa60CkParse Yosys format string into literal parts and format \xe2\x80\xa60CfPer-partition X-capability flag. Indexed by a flat \xe2\x80\xa6Bothe staged primary output pins for next levels.0Ci(for debug purpose) the relation between major stage, \xe2\x80\xa60BnTrace back the critical path from an endpoint.0AjWrite data setup time (ps)0AoThe number of boomerang stages.0C`Effective per-cycle state size for GPU dispatch.CcCheck if a cell has multiple outputs (like adders).0CbLoad timing from an SDF file with per-instance \xe2\x80\xa60BiAuto-detect VCD scope containing the DUT.0CaCompute the popcount of the union of two bitsets.0CmDirectly evaluate a behavioral model\xe2\x80\x99s gate network for \xe2\x80\xa60CmPopulate display format information from JSON attributes. \xe2\x80\xa60AjThe addr width of an SRAM.0CjCompute the full set of X-capable AIG pins via forward \xe2\x80\xa6ChFormat a display message given the format string and \xe2\x80\xa60CgParse a functional Verilog model file (*.functional.v).0CiRun CPU sanity check for X-propagation, comparing GPU \xe2\x80\xa6CmWrite simulation results to output VCD with X-propagation \xe2\x80\xa6CmExpand value-only state buffer into a doubled buffer with \xe2\x80\xa6CeBuild an AIG from a netlistdb, using explicit PDK \xe2\x80\xa60ClInject timing delay data into the GPU script\xe2\x80\x99s padding \xe2\x80\xa60ClGet the maximum propagation delay through this cell (for \xe2\x80\xa60CiX-propagation-aware CPU partition executor for script \xe2\x80\xa6CjBuild timing constraint buffer for GPU-side setup/hold \xe2\x80\xa60CkDetect library from a Verilog file by scanning for cell \xe2\x80\xa60BmGet required input port names from netlistdb.0BiRead clock to data output fall delay (ps)0BiRead clock to data output rise delay (ps)0CmConvert a parsed behavioral model to an AIG decomposition \xe2\x80\xa60CmPerform a topological traversal and also produce a bitset \xe2\x80\xa60CaCheck if a VCD scope contains all required ports.0CgMaximum number of timing violations before stopping \xe2\x80\xa60CjBuild a per-word timing constraint buffer for GPU-side \xe2\x80\xa60ClExtract display cell information from a Yosys JSON file. \xe2\x80\xa60ClRead a cluster solution from hgr.part.xx file. Then call \xe2\x80\xa60")